\chapter{Software Design}
In diesem Kapitel wird ein mögliches Design für den Robocup erläutert.
\section{Einführung}
Bis anhin hat die \acrshort{hftm} mit dem Team Solidus am Robocup bereits an der Spitze mitgespielt. So fragt man sich vielleicht, wieso diese Arbeit überhaupt zu Stande kommt. Bis heute entwickelt man mit einem monolithischen Ansatz. Das Meiste ist eng miteinander verzahnt und die Software lässt sich schwer und mit viel Zeit weiterentwickeln. Der Roboter für den Wettbewerb wird gleichzeitig aber ständig komplexer und es müssen immer wieder neue Dinge (Bsp. Sensoren) integriert werden. Auch müssen sich die Schüler jedes Jahr durchgehend mit allen Schichten bzw. Teilen (von Hardware bis Business-Logik) neu befassen. In den nachfolgenden Abschnitten soll gezeigt werden, wie man die einzelnen Systeme des Roboters in Domänen (Positionierung, Fahr-Einheit, Greifsystem, etc.) unterteilt und dazwischen simple und nachhaltigere Schnittstellen realisieren kann.
Jede einzelne Komponente im System verwendet zum Austausch mit Anderen den Systemweiten Event-Bus, egal zu welcher Domain sie gehört.

\section{Monolith vs. Microservice}
Man hört es heute an jedem Enwickler-Event, liest es in verschiedenen Zeitschriften, egal ob für Entwickler oder System-Administratoren: der Weg zum Ziel sollen Microservices sein, sie sollen Monolithen ablösen. Viele kleine Services statt einen grossen, verzahnten und schwierig wartbaren Moloch. 
In \cite{informatik-aktuell-microservices} findet sich ein passendes Statement zur monolithischen Applikation:
\begin{quote}
	Selbstverständlich startet keine Neuentwicklung als ,,grosser Monolith". Anfangs ist die Anwendung schlank, leicht zu erweitern und gut zu verstehen – die Architektur adressiert die Probleme, die das Team zu dieser Zeit hat. Im Laufe der Monate entsteht mehr und mehr Code. Es werden Schichten definiert, Abstraktionen gefunden, Module, Services und Frameworks eingeführt, um die wachsende Komplexität in den Griff zu bekommen.
	
	Bereits bei mittelgrossen Anwendungen (etwa eine Java-Anwendung mit mehr als 50.000 LOC\footnote{Lines of Code}) werden monolithische Architekturen langsam unangenehm. Das gilt vor allem für Anwendungen, die hohe Anforderungen an die Skalierbarkeit stellen. Aus der schlanken Neuentwicklung entwickelt sich das nächste Legacy-System, über das folgende Generationen von Entwicklern fluchen werden.
\end{quote}
Die Vorteile von Microservices sprechen für sich. Deshalb setzen auch die Internetriesen wie Netflix, Amazon, eBay und Uber seit einiger Zeit darauf. Hier ein Auszug der wichtigsten Punke aus der selben Quelle\cite{informatik-aktuell-microservices}, die für den Roboter interessant sind:
\begin{itemize}
	\item
Aufgrund ihrer geringen Grösse benötigt man wenig Boiler-Plate Code und keine schwergewichtigen Frameworks.
	\item
Sie lassen sich unabhängig voneinander deployen. Continuous Delivery bzw. Deployment lässt sich damit sehr viel einfacher realisieren.
	\item
Die Architektur unterstützt die Arbeit in mehreren, unabhängigen Teams.
	\item
Es ist pro Service möglich, die jeweils „beste“ Programmiersprache zu wählen. Man kann ohne grosses Risiko auch mal eine neue Sprache, ein neues Framework oder ähnliches ausprobieren. Man sollte es dabei nur nicht übertreiben.
	\item
Da sie klein sind, lassen sie sich auch jederzeit mit vertretbarem Aufwand durch eine Neuentwicklung ablösen.
	\item
Microservices kommen der agilen Entwicklung entgegen. Ein neues Feature, von dessen Erfolg beim Kunden man noch nicht überzeugt ist, lässt sich nicht nur schnell entwickeln – es lässt sich auch schnell wieder wegwerfen.
\end{itemize}
Folgendes Argument kommt noch dazu: Durch die Tatsache, dass die Schnittstellen klar definiert sind, lassen sich an einem Service jederzeit einfache Blackbox-Tests durchführen: Man versorgt den Service an der Schnittstelle mit den Testdaten und prüft, ob die richtigen Daten raus kommen. Diesen Punkt werden wir später in diesem Dokument anhand des Lidar-Services anschauen.

Natürlich gibt es mit Microservices auch Nachteile, die man nicht verschweigen sollte:
\begin{itemize}
	\item
	Durch die Kapselung in einzelne Komponenten (und sogar eigene Java VMs) braucht es  grundsätzlich mehr Ressourcen.
	\item
	Es entsteht mehr Netzwerk Traffic. Objekte werden in einer YAML-/JSON-/(XML)-Struktur serialisiert übers Netzwerk versendet. Der Consumer-Service muss diese dann wieder in Objekte "abfüllen" (marshalling/unmarshalling).
	
\end{itemize}


\section{Architektur}
Im Kapitel \ref{sec:mqtt} wird beschrieben, dass auf dem Roboter bis jetzt bereits einiges über den Event-Bus \acrshort{mqtt} kommuniziert. Dies bildet auch in der neuen Architektur die zentrale Komponente. Es gäbe auch andere Event-/Message-Busse, die dafür verwendet werden könnten (Bsp. \acrshort{ros}). \acrshort{mqtt} ist durch die Verwendung in Heimautomationen bereits weit verbreitet und es gibt Libraries für unterschiedliche Programmiersprachen und eine grosse Community dafür, aber vor allem kennen die Studenten der HFTM \acrshort{mqtt} bereits. Es sollen also Micro-Services entstehen, die nur genau eine Aufgabe erfüllen. Einige werden nur das hardware-spezifische Protokoll (hier \acrshort{lidar}) in die \acrshort{mqtt}-Welt adaptieren. \Glspl{service} kennen sich untereinander nicht, sie wissen nichts von der Existenz anderer \glspl{service}. Damit die einzelnen \Glspl{service} miteinander kommunizieren können, kommen so genannte \Glspl{servant} zum Einsatz. Diese kennen die Schnittstellen (\gls{contract}/\acrshort{api}) der zu bedienenden Services. Wir werden dieses Konzept in den nachfolgenden Kapitel am Beispiel des \acrshort{lidar} anschauen.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{img/architecture/highlevel.png}
	\caption{Architektur in Domains}
	\label{fig:architecture_highlevel}
\end{figure}

Der ,,Datenfluss'' der Lidar-Sensordaten bis zur Drive-Einheit (Motoransteuerung etc.) könnte somit beispielsweise wie folgt aussehen:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{img/architecture/dataflow.png}
	\caption{Datenfluss Sensordaten zur Drive-Einheit}
	\label{fig:architecture_dataflow}
\end{figure}
Die einzelnen Services werden durch die jeweiligen Servants verbunden.


\section{Aufbau eines Services, Begriffe}
\label{sec:isePattern}
Jeder Service im System soll sich an in diesem Abschnitt beschriebenen Grundsatz halten. Als Student der BFH mit Mobile Computing als Schwerpunkt lernt man bei Reto Koenig folgendes Muster für die MQTT-Topics kennen: Intent, Status und Event. Was das bedeutet wird in den nächsten Abschnitten beschrieben. Die \acrshort{mqtt}-Topics stellen das \acrshort{api} für den jeweiligen Service dar.
\subsection{Payload}
In der Payload der Topics befinden sich nicht nur Werte (wie bisher) sondern eine Dokumentstruktur mit \acrshort{yaml}-Inhalt. YAML deshalb, damit man mit einem MQTT-Client (z.B. MQTTlens oder MQTTfx) für den Mensch verständlich ist. Jede Payload enthält mindestens einen Zeitstempel mit der Systemzeit als die Meldung ins MQTT-System eingespiesen wurde. Der Zeitstempel wird beim ,,durchschleifen'' einer Nachricht von Service zu Service vom Servant nicht verändert. Die nachfolgenden Teilabschnitte basieren auf dem englischen README aus dem Github-Projekt \verb|ch.quantasy.mqtt.gateway|\cite{ch.quantasy.mqtt.gateway}.
\subsubsection{Beispiel einer MQTT-Payload}
\begin{lstlisting}
---
- timeStamp: 65630678285913
command: "SINGLE_MEAS"
\end{lstlisting}

\subsection{Unit}
Als \gls{unit} wir eine Instanz eines Services bezeichnet. Im Hardware-Service für den \acrshort{lidar}-Sensor wird pro konfigurierter Sensor eine Instanz des eigentlichen Services erstellt. Das sind also unterschiedliche Units.
\subsection{Intent}
Kann ein Service Befehle über die \acrshort{mqtt}-\acrshort{api} entgegennehmen, so werden diese über das Topic '\gls{intent}' dem Service mitgeteilt. Dafür muss sich der Service auf dieses Topic abonnieren ('subscribe'). Pro Service gibt es nur ein Intent-Topic.
\subsection{Status}
Mehrheitlich statische Informationen stellt ein Service unter dem Basis-Topic '\gls{status}' zur Verfügung. Beispielsweise ordne ich jegliche Informationen über den Lidar Sensor in diese Kategorie ein: Firmwarestand, Konfiguration, State des Sensors (Initialisierung des Sensors / Messung läuft / Standby / etc.). Unter diesem Topic kann eine beliebige Baumstruktur aufgebaut werden.
\subsection{Event}
Die Messwerte des Sensors gehören beispielsweise in dieses Topic. Alle Informationen, die eventgesteuert sind oder auftreten können, klassifizieren wir in diese Kategorie.
\subsection{Description}
Im Topic '\gls{description}' beschreibt ein Service bzw. eine \acrshort{unit} beim Aufstarten angebotene \acrshort{api}. Das ermöglicht für Entwickler die Anbindung an andere Komponenten. Die Description des APIs ist vor allem für die Entwicklung von Services relevant, die nicht den im nachfolgenden Kapitel beschriebenen GatewayClient verwenden.
\subsection{Beispiel}

\begin{verbatim}
Robocup/Lidar/U/192.168.91.2@kicm-fedora.localdomain/S/connection
         ^    ^       ^                              ^  ^
         |    |       |                              |  |
         |    |       |                              |  '--- Topic unterhalb 'Status'
         |    |       |                              '------ Status Trennzeichen
         |    |       '------------------------------------- Name der Unit / Instanz
         |    '--------------------------------------------- Unit Trennzeichen
         '-------------------------------------------------- Name des Services
\end{verbatim}

