\chapter{Implementation der Beispielservices für den Lidar}
Hier gehe ich darauf ein, wie sich das Konzept aus Kapitel \ref{chap:software-design} in Programmcode umsetzen lässt. Dabei versuche ich den Code so einfach wie möglich zu halten, da die Schüler der HFTM parallel erst an Java ausgebildet werden (siehe Anforderungen aus Abschnitt \ref{chap:aufgabenstellung}). Auf Lambda-Ausdrücke wird beispielsweise verzichtet.
\label{chap:beispielimplementation}
\section{Die Library 'GatewayClient'}
Mit der  Java-Library \verb|ch.quantasy.mqtt.gateway| von Reto Koenig\cite{ch.quantasy.mqtt.gateway} lässt sich einfach ein Microservice entwickeln, der sich bereits an das Muster aus Kapitel \ref{sec:isePattern} hält. Man kann damit keine Messages ins MQTT publizieren die das Muster verletzen. 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{img/ch.quantasy.mqtt.gateway/GatewayClient.png}
	\caption{GatewayClient, ch.quantasy.mqtt.gateway\cite{ch.quantasy.mqtt.gateway}}
	\label{fig:gatewayclient}
\end{figure}
In Abbildung \ref{fig:gatewayclient} ist ersichtlich wie die Library die Basis-Topics bzw. \acrshort{api}s in Richtung MQTT-Broker zur Verfügung stellt. Die Idee hinter dem \verb|GatewayClient| ist folgende:
\begin{itemize}
	\item
	Standardisieren der Schnittstelle. Man wird zwar ,,eingeengt'' aber dafür ist die Schnittstelle einheitlich.
	\item
	Serialisierung und übertragen der Java-Objekte auf MQTT (bei den published Topics)
	\item
	Deserialisierung der YAML-Daten in die ursprünglichen Java-Objekte (bei den subscribed Topics)
	\item
	Bei jedem Verbinden zum MQTT-Broker publiziert der GatewayClient automatisch die ,,\acrshort{api}-Dokumentation''. So ist sofort ersichtlich was für eine Schnittstelle implementiert werden muss um einen weiteren \Gls{servant} an diese Schnittstelle anzuschliessen.
\end{itemize}
\subsection{Service Logik}
An den GatewayClient wird die eigentliche Service Logik angebunden. Im Github-README unterscheidet Reto Koenig\cite{ch.quantasy.mqtt.gateway} dabei wie in Abbildung \ref{fig:microService} ersichtlich zwischen 'Service Logic' und 'Service Source':
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{img/ch.quantasy.mqtt.gateway/MicroService.png}
	\caption{Micro-Service mit GatewayClient \cite{ch.quantasy.mqtt.gateway}}
	\label{fig:microService}
\end{figure}
Was das bedeutet, erklären die nächsten zwei nächsten Abschnitte.
\subsubsection{Service Source}
In 'Service Source' gehören die Libraries zu einer bestimmten Hardware. Der Hersteller Tinkerforge\cite{tinkerforge-gmbh} stellt beispielsweise den Java-Code und die Library für die Anbindung ihrer Produkte bereit. Diese Kategorie beinhaltet also die Ansteuerung der Hardware aus Java. Ab diesem Punkt haben wir also Objekte und Klassen, die wir mit der 'Service Logic' ansteuern können.
\subsubsection{Service Logic}
Unter 'Service Logic' versteht man die eigentliche (abstrahierte) Logik um einen Sensor/Aktor/etc. an den GatewayClient anzubinden.


\section{TiM55x-Service}
Der TiM55x-Service enthält (dh. \verb|import|) zum einen den GatewayClient sowie die Library der HFTM zur Dekodierung und Ansteuerung des Lidars (also der 'Service Source'). Wir müssen uns folglich also um die 'Service Logic' aus Abbildung \ref{fig:lidarservice} kümmern.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{img/ch.quantasy.mqtt.gateway/LidarService.png}
	\caption{TiM55x-Service, Quelle des Diagramm-Templates: \cite{ch.quantasy.mqtt.gateway}}
	\label{fig:lidarservice}
\end{figure}

Der TiM55x-Service ist wie in Abbildung \ref{fig:structure_lidarservice} strukturiert. Alles aus dem Java-Package 'contract' kennt auch der Consumer bzw. Provider von unserem Service, also der Servant - solange er auch den GatewayClient verwendet. Darin enthalten ist also die Definition der Schnittstelle und (Objekt-)Strukturen der Daten, die auf dem Event-Bus vorhanden sind.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{img/implementation/lidar-adapter/structure.png}
	\caption{TiM55x-Service, Struktur}
	\label{fig:structure_lidarservice}
\end{figure}

Beginnen wir nun mit der Implementation. Der Programmcode in den nachfolgenden Abschnitten ist meist nicht vollständig, damit es übersichtlicher bleibt (mit '\verb|// ...|' gekennzeichnet). Der vollständige Code dieser Arbeit befindet sich auf Github\cite{github-thesis}. \\
\subsection{Contracts definieren}
Als erstes wird der \Gls{contract} - also die MQTT-Topics und die Struktur der \Gls{payload} - definiert. Dazu wird die Basis-Klasse \verb|AyamlServiceContract| wie in Listing \ref{lst:lidarservice-contracts} ersichtlich erweitert.
\begin{lstlisting}[caption={TiM55x-Service - Contracts},label={lst:lidarservice-contracts}]
public class LidarServiceContract extends AyamlServiceContract {
    public final String STATE, MEASUREMENT, STATUS_STATE, EVENT_MEASUREMENT;
    // ...

    public LidarServiceContract(String instanceID) {
        super("Robocup", "Lidar", instanceID);
        STATE = "state";
        MEASUREMENT = "measurement";
        STATUS_STATE = STATUS + "/" + STATE;
        EVENT_MEASUREMENT = EVENT + "/" + MEASUREMENT;
    }

    @Override
    public void setMessageTopics(Map<String, Class<? extends Message>> messageTopicMap) {
        messageTopicMap.put(INTENT, LidarIntent.class);
        messageTopicMap.put(EVENT_MEASUREMENT, LidarMeasurementEvent.class);
        messageTopicMap.put(STATUS_STATE, LidarState.class);
    }
}
\end{lstlisting}
Der \acrshort{lidar}-Service verwendet also über diesen \Gls{contract} die folgenden \Glspl{topic}:
\begin{itemize}
	\item \path{<rootContext>/<baseClass>/U/<instanceID>/I}
	\item \path{<rootContext>/<baseClass>/U/<instanceID>/S/state}
	\item \path{<rootContext>/<baseClass>/U/<instanceID>/E/measurement}
\end{itemize}
und durch Vererbung:
\begin{itemize}
	\item \path{<rootContext>/<baseClass>/U/<instanceID>/S/connection}
\end{itemize}
, wobei über den Aufruf \verb|super(rootContext: "Robocup", baseClass: "Lidar", instanceID)| die variablen Teile der \Glspl{topic} entsprechend gesetzt werden.

Schauen wir uns als Beispiel noch das 'measurement'-\Gls{topic} an. Eine Momentaufnahme des \acrshort{lidar}-Sensors also eine Messung beinhaltet 270 Messpunkte mit dieser Struktur:
\begin{lstlisting}[caption={TiM55x-Service - Struktur der Messpunkte},label={lst:lidar_measurement}]
public class Measurement {
    @Range(from = -45, to = 225)
    public int angle;
    
    @Range(from = 0, to = 10000)
    public int distance;
    
    @Range(from = 0, to = 10000)
    public int rssi;

    public Measurement(int angle, int distance, int rssi){
        this.angle = angle;
        this.distance = distance;
        this.rssi = rssi;
    }
    // ...
}
\end{lstlisting}
Über die Annotations geben wir den Variablen die möglichen Werte vor. Damit werden zum einen beim Aufstarten die \Gls{description}-Topics korrekt abgefüllt und zum anderen lassen sich die Empfangenen Werte mit dem \Gls{gatewayclient} validieren (optional). So kann man beispielsweise bestimmen, ob nicht valide Werte weiterverarbeitet werden oder nicht.
Die obigen Messpunkte einer Messung werden in einer Liste als 'LidarMeasurementEvent' übermittelt:
\begin{lstlisting}[caption={TiM55x-Service - Struktur des 'LidarMeasurementEvent'},label={lst:lidar_measurementevent}]
public class LidarMeasurementEvent extends AnEvent{
    private ArrayList<Measurement> measurements;
    
    public LidarMeasurementEvent(ArrayList<Measurement> measurements) {
        this.measurements = measurements;
    }
    // ...
}
\end{lstlisting}

\subsection{Service Logik implementieren}
Die nachfolgenden Code-Snippets aus Listing \ref{lst:TiM55x-service} zeigen den Aufbau des TiM55x-Service. Der GatewayClient wird über \verb|<LidarServiceContract>| mit dem \Gls{contract} instantiiert, damit er die Schnittstelle kennt. Bei den Zeilen mit \verb|IScanListener ... |, \verb|IScanOperator ...| sowie \verb|new TiM55x(...)| sieht man die Anbindung an die Sensor-Libary. Andersherum bei \verb|MessageReceiver| und \verb|gatewayClient.subscribe| die Anbindung mit dem GatewayClient an \acrshort{mqtt}. Der Code zeigt also schön, wie die 'Service Logic' beide ,,Welten'' zusammenklebt.
\lstinputlisting[caption={Aufbau TiM55x-Service},language=Java,label={lst:TiM55x-service}]{listings/lidarservice_new.java}

\subsection{Tests mit JUnit}
Der TiM55x-Service verwendet als '\Gls{service-source}' die Library der HFTM. Theoretisch müsste hier also die '\Gls{service-logic}' per Unit-Test getestet werden. Ein einfacher Unittest ist aber ohne beiden Libraryies '\Gls{service-source}' und '\Gls{gatewayclient}' zu Mocken fast nicht möglich und auch nicht sehr aussagekräftig. Deshalb werden am Service lediglich Integrationstests mit JUnit durchgeführt.
\subsubsection{Integrationstest initialisieren}
Initialisiert wird das Setup wie folgt:
\begin{lstlisting}[caption={Integrations-Test Setup für TiM55x},label={lst:integrationstest-tim55x-setup}]
public class TiM55xServiceIntegrationTest {
    // ..
    static int LIDAR_PORT = 2112;
    static String LIDAR_IP = "127.0.0.1";
    static String MQTT_BROKER = "tcp://127.0.0.1:11234";
    //.. 
    @BeforeAll
    public static void setUpBeforeClass() {
        mqttURI = URI.create(MQTT_BROKER);
        //..
        try {
            // Embedded Broker
            // https://github.com/andsel/moquette/blob/master/
            // embedding_moquette/src/main/java/io/moquette/
            // testembedded/EmbeddedLauncher.java
            EmbeddedBrokerLauncher embeddedBrokerLauncher = new EmbeddedBrokerLauncher();

            // Start Hardware Mock
            Runnable r = new Runnable() {
            @Override
                public void run() {
                    try {
                        new HardwareMock(LIDAR_PORT);
                    } catch (InterruptedException e) {
                        LOGGER.error("InterruptedException: ", e);
                    }
                }
            };
            new Thread(r).start();
            Thread.sleep(2000);

            // GatewayClient
            gatewayClient = new GatewayClient<TiM55xServiceTestContract>(mqttURI, mqttClientName, new TiM55xServiceTestContract(instanceName));
            gatewayClient.connect();
            Thread.sleep(1000);
        } catch (Exception e) {
            fail("Exception during Setup");
        } 
    }
    
    // Test case 1
    // ...
    // Test case n
}
\end{lstlisting}
Wir starten also gleich zwei Umsysteme damit - einen Mock-Service (siehe Kapitel \ref{chap:tim-mock}) und einen MQTT-Broker. Damit lässt sich das ganze auch wieder automatisieren. Wir müssen also nicht von Hand einen Sensor ans Netzwerk anschliessen und den Broker starten. Der JUnit-Test erledigt alles für uns.
\subsubsection{Test-Szenario 'TiM55x-Service starten'}
Kommen wir also zum ersten Test-Szenario: den TiM55x-Service starten.
\begin{lstlisting}[caption={TiM55x Startup-Test}]
@Test
@DisplayName("Start TiM55x Service")
public void bringTiM55xServiceUp() {
    try {
        tiM55xService = new TiM55xService(mqttURI, "SomeTestingWithTiM55x", "SomeTestingWithTiM55x",LIDAR_IP, LIDAR_PORT);
        Thread.sleep(2000);
    } catch (Exception e) {
        fail("Exception during TiM55x Startup");
    }
}
\end{lstlisting}

\subsubsection{Test-Szenario 'Status-Topic prüfen'}
Jetzt wird es spannender. Wir prüfen jetzt wie sich der Status vom TiM55x-Service verhält. Dazu abonnieren wir das entsprechende Topic beim MQTT-Broker und prüfen ob der Status 'online' entspricht (\verb|assertEquals(...)|). Ansonsten wird der Test den Zustand Fail annehmen.
\begin{lstlisting}
@Test
@DisplayName("Subscription to Connection Status Topic")
public void subscribeStatus() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);

    MessageReceiver messageReceiver = new MessageReceiver() {
        @Override
        public void messageReceived(String topic, byte[] payload) throws Exception {
            LOGGER.trace("Payload: " + new String(payload));
            resultConnectionStatus = (ConnectionStatus) gatewayClient.toMessageSet(payload, ConnectionStatus.class).last();
            latch.countDown();
        }
    };

    this.gatewayClient.subscribe(tempLidarServiceContract.STATUS_CONNECTION, messageReceiver);
    latch.await(100, TimeUnit.SECONDS);
    assertEquals("online", resultConnectionStatus.value);
}
\end{lstlisting}

\section{UI-Service}

\section{TiM55x-zu-UI-Servant}
\section{TiM55x Mock}
\label{chap:tim-mock}

\section{TODO}

